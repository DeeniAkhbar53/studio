
'use server';

import { db } from './firebase';
import { collection, getDocs, addDoc, doc, updateDoc, deleteDoc, serverTimestamp, query, orderBy } from 'firebase/firestore';
import type { Miqaat } from '@/types';

const miqaatsCollectionRef = collection(db, 'miqaats');

export const getMiqaats = async (): Promise<Miqaat[]> => {
  try {
    const q = query(miqaatsCollectionRef, orderBy('startTime', 'desc')); // Fetch newest first by start time
    const data = await getDocs(q);
    return data.docs.map((doc) => ({ ...doc.data(), id: doc.id } as Miqaat));
  } catch (error) {
    console.error("Error fetching miqaats: ", error);
    throw error;
  }
};

// Type for data when adding a new Miqaat.
// id is generated by Firestore, barcodeData can be optional (service provides default).
export type MiqaatDataForAdd = Omit<Miqaat, 'id' | 'barcodeData'> & { barcodeData?: string };

export const addMiqaat = async (miqaatData: MiqaatDataForAdd): Promise<Miqaat> => {
  try {
    const payload: any = {
        ...miqaatData,
        teams: Array.isArray(miqaatData.teams) ? miqaatData.teams : [], // Ensure teams is an array
        createdAt: serverTimestamp() 
    };
    if (!payload.barcodeData) {
        // Generate a default barcode if not provided, e.g., MIQAAT- followed by timestamp
        payload.barcodeData = `MIQAAT-${Date.now()}`;
    }

    const docRef = await addDoc(miqaatsCollectionRef, payload);
    // Return the miqaatData with the new ID and potentially generated barcode.
    // For createdAt, Firestore handles it, so it won't be in the immediate return unless fetched.
    return { ...miqaatData, id: docRef.id, barcodeData: payload.barcodeData } as Miqaat;
  } catch (error) {
    console.error("Error adding miqaat: ", error);
    throw error;
  }
};

// Type for data when updating an existing Miqaat. All fields are optional.
export type MiqaatDataForUpdate = Partial<Omit<Miqaat, 'id'>>;

export const updateMiqaat = async (miqaatId: string, updatedData: MiqaatDataForUpdate): Promise<void> => {
  try {
    const miqaatDoc = doc(db, 'miqaats', miqaatId);
    const updatePayload: any = { ...updatedData };
    // Ensure teams is an array if provided
    if (updatedData.teams && !Array.isArray(updatedData.teams)) {
        console.warn("Teams data for updateMiqaat was not an array, attempting to convert/default.");
        // This case should ideally be handled by Zod transform if data comes from a form
        // For direct calls, ensure it's an array or handle appropriately.
        updatePayload.teams = []; 
    }

     Object.keys(updatePayload).forEach(key => {
      // Firestore doesn't like 'undefined' values.
      if (updatePayload[key] === undefined) {
        delete updatePayload[key]; 
      }
    });
    await updateDoc(miqaatDoc, updatePayload);
  } catch (error) {
    console.error("Error updating miqaat: ", error);
    throw error;
  }
};

export const deleteMiqaat = async (miqaatId: string): Promise<void> => {
  try {
    // Future: Consider checking if there are attendance records tied to this Miqaat before allowing deletion.
    const miqaatDoc = doc(db, 'miqaats', miqaatId);
    await deleteDoc(miqaatDoc);
  } catch (error) {
    console.error("Error deleting miqaat: ", error);
    throw error;
  }
};

